<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WEB GL TEST</title>
    <style>
        .c{
            width: 512px;
            height: 512px;
        }
        body{
            background: white;
        }
        #cntr{
            width: 200px;
            position: absolute;
            left: 512px;
            top: 0px;
        }
    </style>
</head>
<body>
<div class="c">
    <canvas id="c" class="c" width="512" height="512"></canvas>
</div>
<div id="cntr">
    <div id="ui">
        <div id="x"></div>
        <div id="y"></div>
        <div id="angle"></div>
        <div id="scaleX"></div>
        <div id="scaleY"></div>
    </div>
</div>

<img id="img" src="1.png">
</body>
<script>
    const image = document.getElementById("img");
    let canvas = document.createElement("canvas");
    const scale = 1;
    image.onload= ()=>{
        canvas.width = image.width;
        canvas.height = image.height;
        let cxt = canvas.getContext("2d");
        cxt.drawImage(image, 0, 0, image.width, image.height);
        let data = transImageData(cxt.getImageData(0, 0, image.width, image.height - 1).data, cxt.getImageData(0, image.height - 1, 8, 1).data);
        function transImageData(data, scale) {
            let mm = new Array(3);
            for (let n = 0; n < mm.length; n++) {
                let d = mm[n] = new Float32Array(2)
                let u = new Uint8Array(d.buffer);
                for (let m = 0; m < u.length; m++)
                    u[m] = scale[4 * m + n];
            }
            let re = new Array(3);
            for (let n = 0; n < mm.length; n++) {
                if (mm[n][0] === mm[n][1])
                    break;
                re[n] = new Float32Array(data.length / 4);
                let min = mm[n][0];
                let max = mm[n][1];
                let sc = max - min;
                for (let m = 0; m < re[n].length; m++)
                    if (data[4 * m + 3] === 0)
                        re[n][m] = Number.NaN;
                    else if(data[4 * m + n] === 255)
                        re[n][m] = Number.NaN;
                    else
                        re[n][m] = sc * data[4 * m + n] / 250 + min;
            }
            return re;
        }
        draw(data[0],image.width, image.height - 1);
    };

    let gl = document.getElementById("c").getContext("webgl");

    function ratio(v,l){return (2*v-l)/l}

    function draw(data,width,height){
        const ps = new Float32Array(6*2*((width-1)*(height-1)));
        const cs = new Float32Array(ps.length/2);
        const c = [[0, [198, 244, 255, 1]], [.5, [0, 194, 243, 1]], [1, [0, 89, 166, 1]], [1.5, [13, 100, 255, 1]], [2, [15, 21, 167, 1]],
            [2.5, [247, 74, 255, 1]], [3, [188, 0, 184, 1]], [4, [151, 0, 0, 1]], [5, [255, 4, 83, 1]], [7, [255, 98, 69, 1]], [10, [255, 255, 255, 1]], [12, [188, 141, 190, 1]]];

        c.map(val=>{val[1][0]=val[1][0]/255;val[1][1]=val[1][1]/255;val[1][2]=val[1][2]/255;});
        let idx = 0;
        for(let n = 1;n<height;n++){
            for(let m = 1;m<width;m++){
                let pp=[[ratio(m-1,width),ratio(n-1,height),getData(data,m-1,n-1,width)],
                        [ratio(m-1,width),ratio(n,height),getData(data,m-1,n,width)],
                        [ratio(m,width),ratio(n,height),getData(data,m,n,width)],
                        [ratio(m,width),ratio(n-1,height),getData(data,m,n-1,width)]];
                idx += addRectangle(idx,pp,ps,cs);
            }
        }
        function addRectangle(idx,pp,ps,cs){
            let list = pp.filter(value => !isNaN(value[2]));
            if(list.length <3) return 0;
            if(list.length === 3){
                addL(idx,ps,cs,list);
                return 3;
            }else{
                let c = Math.abs(pp[0][2]-pp[2][2])-Math.abs(pp[1][2]-pp[3][2]);
                let l = [];
                if(c>0)
                    l.push(pp[0],pp[1],pp[3],pp[1],pp[2],pp[3]);
                else
                    l.push(pp[0],pp[1],pp[2],pp[0],pp[2],pp[3]);
                addL(idx,ps,cs,l);
                return l.length;
            }
        }

        function addL(idx,ps,cs,l){
            for(let m=0;m<l.length;m++){
                let pi = idx+m;
                ps[2*pi] = l[m][1];
                ps[2*pi+1] = l[m][0];
                cs[pi] = l[m][2];
            }
        }

        function getData(data,row,col,width,height){
            return data[row*width+col];
        }

        const vs = `
attribute vec2 a_position;
attribute vec4 a_color;
uniform mat3 u_matrix;
uniform float u_color[1];
varying vec4 v_color;
  void main() {
    gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
    v_color = a_color;
  }
`;
        const fs = `
precision mediump float;
varying vec4 v_color;
  void main() {
    gl_FragColor = v_color.gbra; // return redish-purple
  }

  
`;

        let translation = [0, 0];
        let angleInRadians = 0;
        let scale = [1, 1];

        drawScene();

        // Setup a ui.
        webglLessonsUI.setupSlider("#x", {value: translation[0], slide: updatePosition(0), min: -10, max: 10, step: 0.1});
        webglLessonsUI.setupSlider("#y", {value: translation[1], slide: updatePosition(1), min: -10, max: 10, step: 0.1});
        webglLessonsUI.setupSlider("#angle", {slide: updateAngle, max: 360});
        webglLessonsUI.setupSlider("#scaleX", {value: scale[0], slide: updateScale(0), min: 1, max: 10, step: 0.1, precision: 2});
        webglLessonsUI.setupSlider("#scaleY", {value: scale[1], slide: updateScale(1), min: 1, max: 10, step: 0.1, precision: 2});

        function updatePosition(index) {
            return function(event, ui) {
                translation[index] = ui.value;
                drawScene();
            }
        }

        function updateAngle(event, ui) {
            let angleInDegrees = 360 - ui.value;
            angleInRadians = angleInDegrees * Math.PI / 180;
            drawScene();
        }

        function updateScale(index) {
            return function(event, ui) {
                scale[index] = ui.value;
                drawScene();
            }
        }

        drawScene();

        function drawScene(){
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            // create GLSL shaders, upload the GLSL source, compile the shaders
            let vertexShader = createShader(gl, gl.VERTEX_SHADER, vs);
            let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fs);
            let program = createProgram(gl, vertexShader, fragmentShader);

            const positionLocation = gl.getAttribLocation(program, "a_position");
            const colorLocation = gl.getAttribLocation(program, "a_color");
            const matrixLocation = gl.getUniformLocation(program, "u_matrix");
            const colorLoc = gl.getUniformLocation(program, "u_color");
            //position
            let positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, ps, gl.STATIC_DRAW);
            //color
            let colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, cs, gl.STATIC_DRAW);
            // Tell WebGL how to convert from clip space to pixels
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.useProgram(program);

            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            let size = 2;          // 2 components per iteration
            let type = gl.FLOAT;   // the data is 32bit floats
            let normalize = false; // don't normalize the data
            let stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position
            let offset = 0;        // start at the beginning of the buffer
            gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset)
            // Turn on the color attribute
            gl.enableVertexAttribArray(colorLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            size = 1;          // 4 components per iteration
            gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset)
            // Compute the matrix
            let matrix = [1,0,0,0,1,0,0,0,1];
            matrix = m3.translate(matrix, translation[0], translation[1]);
            matrix = m3.rotate(matrix, angleInRadians);
            matrix = m3.scale(matrix, scale[0], scale[1]);
            gl.uniformMatrix3fv(matrixLocation, false, matrix);

            gl.uniform1fv(colorLoc,[0,1,2]);
            // draw
            let primitiveType = gl.TRIANGLES;
            let count = idx;
            gl.drawArrays(primitiveType, offset, count);
        }

        function createShader(gl, type, source) {
            let shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (success) {
                return shader;
            }
            gl.deleteShader(shader);
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            let program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            let success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (success) {
                return program;
            }

            console.log(gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
        }
    }
</script>

<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/webgl-lessons-helper.js"></script>
<!-- you can and should delete this script. it is only used on the site to help with errors -->
<script src="https://webglfundamentals.org/webgl/resources/m3.js"></script>

</html>
ch02:
DrawRectangle.html
HelloCanvas.html
HelloPoint1.html
HelloPoint2.html    ==>如何在js和着色器之间传输数据
ClickedPoints.html  ==>在鼠标点击的位置上绘制出点来&&浏览器客户区坐标系==>canvas坐标系==>webgl坐标系变换
ColoredPoints.html

ch03:
MultiPoint.html  ==>缓冲区对象创建，一次性存入多个点
HelloTriangle.html
TranslatedTriangle.html
RotatedTriangle.html
RotatedTriangle_Matrix.html

ch04:
RotatedTriangle_Matrix4.html
RotatingTriangle.html  ||  RotatingTranslatedTriangle.html  ||  RotatingTriangle_withButtons.html

ch05:
MultiAttributeSize.html  ==>为顶点的每种数据建立一个缓冲区，然后分配给对应的attribute变量，就可以向顶点着色器传递多份逐顶点的数据信息了
MultiAttributeSize_Interleaved.html  ==>但当三维图形具有成千上万的顶点时，维护所有顶点数据是很困难的。然而，WebGL允许我们把顶点坐标和尺寸数据等attribute变量打包到同一缓冲区对象中，并通过某种机制分别访问缓冲区对象中不同的数据，比如：本例展示将顶点坐标和尺寸数据交错组织(interleaving)
MultiAttributeColor.html  ==>利用varying变量来修改颜色
ColoredTriangle.html  ==>彩色三角形（内插颜色）：会了解顶点着色器和片元着色器之间的数据传输细节==>几何形状的装配和光栅化过程
HelloTriangle_FragCoord.html  ==>彩色三角形（指定片元颜色）
TexturedQuad.html || TexturedQuad_Repeat.html ||TexturedQuad_Clamp_Mirror.html==>纹理映射，在矩形表面贴上图像
MultiTexture.html  ==>同时处理多幅纹理，纹理单元就是为了这个目的而设计的

ch07:
LookAtTriangles.html  ==>视点、观察目标点、上方向
LookAtRotatedTriangles.html  ==><旋转后的顶点坐标>=<视图矩阵>*<模型矩阵 如旋转矩阵、平移矩阵等等>*<原始顶点坐标>
LookAtRotatedTriangles_mvMatrix.html  ==><旋转后的顶点坐标>=<模型视图矩阵>*<原始顶点坐标>
LookAtTrianglesWithKeys.html  ==>三角形缺了一个角，因为没有指定可视范围，即实际观察得到的区域边界
OrthoView.html  ==>可视空间,<正射投影矩阵>*<原始顶点坐标>
LookAtTrianglesWithKeys_ViewVolume.html  ==>补上缺掉的角,<正射投影矩阵>*<视图矩阵>*<原始顶点坐标>
OrthoView_halfSize.html  ==>如果可视空间近裁剪面的宽高比和<canvas>不一致,显示出的物体就会被压缩变形.本实例将近裁剪面的宽度和高度变为原来的一半,但保持了宽高比==>projMatrix.setOrtho(-0.5, 0.5, -0.5, 0.5, g_near, g_far);三角形变成了之前大小的两倍,因为可视空间变小了
OrthoView_halfWidth.html  ==>它把近裁剪面的宽度缩小为原来的一半,保持其高度不变==>projMatrix.setOrtho(-0.3, 0.3, -1.0, 1.0, g_near, g_far);近裁剪面宽度缩小而高度不变,相当于把长方形的近裁剪面映射到了正方形的<canvas>上,所以绘制出来的三角形就在宽度上拉伸而导致变形了
PerspectiveView.html  ==>可视空间,<透视投影矩阵>*<原始顶点坐标>
PerspectiveView_mvp.html  ==><旋转后的顶点坐标>=<模型视图投影矩阵>*<原始顶点坐标>,虽然只是用了一套数据就画出两套图形,减少了顶点个数,但增加了调用gl.drawArrays()的次数.哪种方法更高效,如何取得平衡,依赖于程序本身和WebGL的实现
PerspectiveView_mvpMatrix.html  ==>因为模型视图投影矩阵和定点没关系,所以可以提出来
DepthBuffer.html  ==>正确处理对象的前后关系==>隐藏面消除:WebGL在默认情况下会按照缓冲区中的顺序(如:顶点先后顺序)绘制图形,而且后绘制的图形覆盖先绘制的图形,因为这样做很高效.但如果顺序不对,显示的就不对了,所以用隐藏面消除
Zfighting.html  ==>正确处理对象的前后关系==>多边形偏移:当两个物体极为接近时,就会出现新的问题,使得表面看上去斑斑驳驳的,这种现象称为"深度冲突"
HelloCube.html  ==>gl.drawElements()替换gl.drawArrays(),通过顶点索引绘制物体
ColoredCube.html  ==>为立方体的每个表面指定颜色.本例将顶点坐标、颜色数据分别存储在不同的两个缓冲区中，并定义了initArrayBuffer封装了缓冲区对象的创建、绑定、数据写入和开启等操作

ch08:光照
// fixme:着色的真正含义是：根据光照条件重建“物体各表面明暗不一的效果”的过程
// fixme:阴影：物体向地面投下影子的现象==>将在第10章
// fixme:光源类型+反射类型
// fixme:光源类型：光的颜色包含强度信息，比如标准的白光为(1,1,1),那么两倍于其强度的白光就表示为(2,2,2)
// fixme:(1)平行光(point light)（类似自然中的太阳光）：方向和颜色
// fixme:(1)点光源光(directional light)（人造灯泡）：位置和颜色
// fixme:(2)环境光(ambient light)（模拟真实世界中的非直射光==>由光源发出后经过墙壁或其他物体反射后的光）：颜色
// fixme:(3)还有如聚光灯光等，看opengl
// fixme:反射类型：
// fixme:(1)漫反射：针对平行光或点光源而言
// fixme:<漫反射光颜色>=<入射光颜色>*<表面基底色>*cosθ,θ为入射光与表面法线形成的夹角
// fixme:(2)环境反射：针对环境光而言
// fixme:<环境反射光颜色>=<入射光颜色>*<表面基底色>
// fixme:当漫反射和环境反射同时存在时，将两个相加，就会得到物体最终被观察到的颜色
LightedCube.html  ==>平行光漫反射
LightedCube_ambient.html  ==>平行光漫反射+环境光环境反射,更真实
LightedTranslatedRotatedCube.html  ==>魔法矩阵:逆转置矩阵:变换后的法向量=变换前的法向量*模型矩阵的逆转置矩阵
PointLightedCube.html  ==>点光源漫反射:与平行光漫反射相比,点光源漫反射在物体表面各位置其光线方向都不同,所以再堆点光源下的物体进行着色时,需要在每个入射点光源计算光源光在该处的方向
PointLightedSphere.html  ||  PointLightedSphere_perFragment.html  ==>左边是逐顶点光照,右边是逐片元光照.右边的更逼真==>可以把东西全放在片元着色器，但不知道为什么一部分放在顶点着色器，一部分放在片元着色器
LightedCube_animation.html
LightedCube_perFragment.html

ch09:
着色器和着色器程序对象:initShaders()函数的作用

ch10:
RotateObject.html  ==>用鼠标控制物体旋转
PickObject.html  ==>选中物体:比如需求：让用户选中三维用户界面上的一个按钮，或者让用户选中三维场景中的多张照片中的某一张
PickFace.html  ==>选中一个表面
HUD.html  ||  3DoverWeb.html  ==>平视显示器HUD（head up display）：最早用于飞行驾驶，三维图形程序，尤其是游戏，也经常在三维场景上叠加文本或二维图形信息
Fog.html ||  Fog_w.html ==>雾化(大气效果)
RoundedPoints.html  ==>绘制圆形的点
LookAtBlendedTriangles.html  ==>α混合简介
BlendedCube.html  ==>α混合--半透明的三维物体
// todo：透明与不透明物体共存：在绘制三维场景时，场景中既有不透明物体也有半透明物体，这时关闭隐藏面消除功能，那些不透明物体的前后关系就会乱套了
// fixme:(1)开启隐藏面消除功能：gl.enable(gl.DEPTH_TEST);
// fixme:(2)绘制所有不透明物体：α=1.0的
// fixme:(3)锁定用于进行隐藏面消除的深度缓冲区的写入操作，使之只读：gl.depthMask(false);
// fixme:(4)绘制所有半透明的物体(α<1.0)。注意它们应当按照深度排序，然后从后向前绘制
// fixme:(5)释放深度缓冲区，使之可读可写
ProgramObject.html  ==>到目前为止，本书中的程序都只是用了一个着色器程序对象。然而对不同的物体需要使用不同的着色器来绘制，每个着色器中可能有非常复杂的逻辑以实现各种不同的效果。所以可以准备多个着色器，然后根据需要切换使用它们
FramebufferObject.html  ==>渲染到纹理
Shadow.html  || Shadow_highp.html  || Shadow_highp_sphere.html ==>绘制阴影

Appendix:
有个导入.vert和.frag文件的东西

gifts:
Particle.html  ==>微粒
Printf.html  ==>通过获取数字图片显示数字
SpecularCube.html  ==>特殊的立方体

学习网站:
          https://developer.mozilla.org/zh-CN/docs/Learn
          https://www.cnblogs.com/lhb25/p/20-webgl-demo-and-examples.html
          https://www.html5tricks.com/tag/webgl
          http://www.wjceo.com/
          http://threepark.net/

          Uber网站==> http://vis.gl/
          流线==> https://mapbox.github.io/webgl-wind/
          WebGL教程==> https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-fundamentals.html
          寻路算法==>http://nullprogram.com/webgl-path-solver/
          http://m.gad.qq.com/article/detail/39119
          https://blog.csdn.net/fengbingchun/article/details/17335477

          Delaunay算法：
          http://jsdo.it/Ryohei.Yagishita/2dQB
          http://www.itkeyword.com/doc/4572633142339745x122/how-to-use-this-javascript-library-in-dart
          http://www.jq22.com/code790
          https://blog.csdn.net/sky_miange/article/details/78677375
          http://www.cnblogs.com/RenLiQQ/archive/2008/02/06/1065399.html
          https://blog.csdn.net/berguiliu/article/details/25003055
          https://blog.csdn.net/u011733376/article/details/70145009

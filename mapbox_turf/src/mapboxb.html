<!DOCTYPE html>
<html>
<head>

    <meta charset='utf-8' />
    <title></title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src="http://oss.sheetjs.com/js-xlsx/xlsx.full.min.js"></script>     <!--文件导入->>  http://www.jianshu.com/p/74d405940305  -->
    <!--<script src="https://cdn.bootcss.com/jquery/1.10.2/jquery.min.js"></script>
    <script src='//cdn.bootcss.com/mapbox-gl/0.39.1/mapbox-gl.js'></script>
    <link href='//cdn.bootcss.com/mapbox-gl/0.39.1/mapbox-gl.css' rel='stylesheet' />
    <script src='//cdn.bootcss.com/Turf.js/4.5.2/turf.js' charset='utf-8'></script>-->
    <script src='https://cdn.bootcss.com/Turf.js/4.5.2/turf.js' charset='utf-8'></script>
    <script src="http://code.jquery.com/jquery-1.7.1.min.js"></script>
    <script src='https://api.mapbox.com/mapbox-gl-js/v0.37.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v0.37.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        .btn-control {
            background-color: #3386c0;
            color: #fff;
            cursor: pointer;
        }

        .btn-control:hover {
            background-color: #4ea0da;
        }

        .coordinates {
            background: rgba(0,0,0,0.5);
            color: #fff;
            position: absolute;
            bottom: 10px;
            left: 10px;
            padding:5px 10px;
            margin: 0;
            font-size: 11px;
            line-height: 18px;
            border-radius: 3px;
            display: none;
        }

        .rangemenu{
             display: block;
             height: 300px;
             width:550px;
             top:20px;
             left:10%;
             margin-left:-100px;
             position: absolute;
         }

        .routeTable{
            border-width: 2px;
            border-color: #222222;
        }
        .btn-control1 {
            font:bold 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
            background-color: #3386c0;
            color: #fff;
            position: relative;
            top: -20px;
            left: 50%;
            border: none;
            width: 200px;
            margin-left:-100px;
            display: block;
            cursor: pointer;
            padding: 10px 20px;
            border-radius: 3px;
        }

        .btn-control1:hover {
            background-color: #4ea0da;
        }
        .btn-control2 {
            text-align: center;
            font:bold 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
            background-color: #3386c0;
            color: #fff;
            position: relative;
            top: 20px;
            left: 40%;
            border: none;
            width: 152px;
            margin-left:-100px;
            display: block;
            cursor: pointer;
            padding: 10px 20px;
            border-radius: 3px;
        }

        .btn-control2:hover {
            background-color: #4ea0da;
        }
    </style>
    <script>
        var saveAs = saveAs || (function(view) {
                "use strict";
                // IE <10 is explicitly unsupported
                if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
                    return;
                }
                var
                    doc = view.document
                    // only get URL when necessary in case Blob.js hasn't overridden it yet
                    , get_URL = function() {
                        return view.URL || view.webkitURL || view;
                    }
                    , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
                    , can_use_save_link = "download" in save_link
                    , click = function(node) {
                        var event = new MouseEvent("click");
                        node.dispatchEvent(event);
                    }
                    , is_safari = /constructor/i.test(view.HTMLElement) || view.safari
                    , is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
                    , throw_outside = function(ex) {
                        (view.setImmediate || view.setTimeout)(function() {
                            throw ex;
                        }, 0);
                    }
                    , force_saveable_type = "application/octet-stream"
                    // the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
                    , arbitrary_revoke_timeout = 1000 * 40 // in ms
                    , revoke = function(file) {
                        var revoker = function() {
                            if (typeof file === "string") { // file is an object URL
                                get_URL().revokeObjectURL(file);
                            } else { // file is a File
                                file.remove();
                            }
                        };
                        setTimeout(revoker, arbitrary_revoke_timeout);
                    }
                    , dispatch = function(filesaver, event_types, event) {
                        event_types = [].concat(event_types);
                        var i = event_types.length;
                        while (i--) {
                            var listener = filesaver["on" + event_types[i]];
                            if (typeof listener === "function") {
                                try {
                                    listener.call(filesaver, event || filesaver);
                                } catch (ex) {
                                    throw_outside(ex);
                                }
                            }
                        }
                    }
                    , auto_bom = function(blob) {
                        // prepend BOM for UTF-8 XML and text/* types (including HTML)
                        // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
                        if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
                            return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
                        }
                        return blob;
                    }
                    , FileSaver = function(blob, name, no_auto_bom) {
                        if (!no_auto_bom) {
                            blob = auto_bom(blob);
                        }
                        // First try a.download, then web filesystem, then object URLs
                        var
                            filesaver = this
                            , type = blob.type
                            , force = type === force_saveable_type
                            , object_url
                            , dispatch_all = function() {
                                dispatch(filesaver, "writestart progress write writeend".split(" "));
                            }
                            // on any filesys errors revert to saving with object URLs
                            , fs_error = function() {
                                if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
                                    // Safari doesn't allow downloading of blob urls
                                    var reader = new FileReader();
                                    reader.onloadend = function() {
                                        var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
                                        var popup = view.open(url, '_blank');
                                        if(!popup) view.location.href = url;
                                        url=undefined; // release reference before dispatching
                                        filesaver.readyState = filesaver.DONE;
                                        dispatch_all();
                                    };
                                    reader.readAsDataURL(blob);
                                    filesaver.readyState = filesaver.INIT;
                                    return;
                                }
                                // don't create more object URLs than needed
                                if (!object_url) {
                                    object_url = get_URL().createObjectURL(blob);
                                }
                                if (force) {
                                    view.location.href = object_url;
                                } else {
                                    var opened = view.open(object_url, "_blank");
                                    if (!opened) {
                                        // Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
                                        view.location.href = object_url;
                                    }
                                }
                                filesaver.readyState = filesaver.DONE;
                                dispatch_all();
                                revoke(object_url);
                            }
                        ;
                        filesaver.readyState = filesaver.INIT;

                        if (can_use_save_link) {
                            object_url = get_URL().createObjectURL(blob);
                            setTimeout(function() {
                                save_link.href = object_url;
                                save_link.download = name;
                                click(save_link);
                                dispatch_all();
                                revoke(object_url);
                                filesaver.readyState = filesaver.DONE;
                            });
                            return;
                        }

                        fs_error();
                    }
                    , FS_proto = FileSaver.prototype
                    , saveAs = function(blob, name, no_auto_bom) {
                        return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
                    }
                ;
                // IE 10+ (native saveAs)
                if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
                    return function(blob, name, no_auto_bom) {
                        name = name || blob.name || "download";

                        if (!no_auto_bom) {
                            blob = auto_bom(blob);
                        }
                        return navigator.msSaveOrOpenBlob(blob, name);
                    };
                }

                FS_proto.abort = function(){};
                FS_proto.readyState = FS_proto.INIT = 0;
                FS_proto.WRITING = 1;
                FS_proto.DONE = 2;

                FS_proto.error =
                    FS_proto.onwritestart =
                        FS_proto.onprogress =
                            FS_proto.onwrite =
                                FS_proto.onabort =
                                    FS_proto.onerror =
                                        FS_proto.onwriteend =
                                            null;

                return saveAs;
            }(
                typeof self !== "undefined" && self
                || typeof window !== "undefined" && window
                || this.content
            ));
        // `self` is undefined in Firefox for Android content script context
        // while `this` is nsIContentFrameMessageManager
        // with an attribute `content` that corresponds to the window

        if (typeof module !== "undefined" && module.exports) {
            module.exports.saveAs = saveAs;
        } else if ((typeof define !== "undefined" && define !== null) && (define.amd !== null)) {
            define("FileSaver.js", function() {
                return saveAs;
            });
        }

    </script>
</head>
<body>
<div id='map'></div>
<pre id='coordinates' class='coordinates'></pre>
<div id="routeMain" class="rangemenu" >
    <div class="routeDivdiv" id="routeDivdiv" style="height:300px;overflow-y: auto;">
        <table id="routeTable" class="routeTable" style="text-align:center;width: 500px;margin-top: 18px;">
            <thead class="routeTablehead" id="routeTablehead">
            <tr>
                <td>序号(No.)</td>
                <td>纬度(Lat)</td>
                <td>经度(Long)</td>
                <td>增加(+)</td>
            </tr>
            </thead>
            <tbody class="routeTablebody" style="text-align:center;width:273px;font-size: small;">
            </tbody>
        </table>
    </div>
</div>
<!--<input type="file" id='upload' class='btn-control2' value="upload" />-->
<label class="ui_button ui_button_primary btn-control2" for="xFile">上传文件</label>
<form><input  type="file" id="xFile" name="file1" style="position:absolute;clip:rect(0 0 0 0);"></form>
<button id='saveto' class='btn-control1'>save</button>
<script>
    mapboxgl.accessToken = 'pk.eyJ1IjoiaGZiNTY0IiwiYSI6ImNqN2I3NnplMTBwb2IzMnJzcWh0OWp6YTQifQ.TM_EQumke3MvFzemeZE48g';
    //引用谷歌地图--raster
    var map = new mapboxgl.Map({
        container: 'map', // container id
        style: {
            "version": 8,
            "sources": {
                "raster-tiles": {
                    "type": "raster",
                    "tiles": ['http://mt0.google.cn/vt/v=w2.114&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}'],     //谷歌地图地址
                    "tileSize": 256
                }
            },
            "layers": [{
                "id": "simple-tiles",
                "type": "raster",
                "source": "raster-tiles",
                "minzoom": 0,
                "maxzoom": 22
            }]
        },
        center: [-74.50, 40], // starting position
        zoom: 1 // starting zoom
    });

    map.addControl(new mapboxgl.NavigationControl());       //加个放大缩小移动map的导航控制

    var countryName='';     //当前选定国家的国家名
    var countryData='';     //当前选定国家的边界点数据

    var isDragging;

    var isCursorOverPoint;

    var coordinates = document.getElementById('coordinates');

    var canvas = map.getCanvasContainer();

    canvas.style.cursor = 'default';        /*初始化是鼠标形状是箭头*/

    var routes={
        "type": "FeatureCollection",
        "features":[]
    };

    var currenti1=-1;       /*选中的国家边界点位于routes数据的下标*/
    var currenti2=-1;       /*如果选中的点是首点，就用这个存尾点下标*/
    var currentj1=-1;       /*如果国家数据是多多边形multipolygon，用这个来存是multipolygon中的哪个polygon*/

    var point = {
        "type": "FeatureCollection",
        "features": [{
            "type": "Feature",
            "geometry": {
                "type": "Point",
                "coordinates": []
            }
        }]
    };

    var aroundCountriesTypes=[];
    var aroundCountriespoints=[];

    map.on('load', function() {     /* on(type,callback)为type事件添加监听器，callback是响应函数*/
        /*$.getJSON("../src/map/naturalMap.json",function(result){    //得把result里的内容分开赋给routes，否则如果直接routes=result的话，会报不是geojson格式错误
            routes.type=result.type;
            routes.features=result.features;
            map.getSource('states').setData(routes);        //得加这句话。不知道load里函数是同时进行，还是从上往下进行，还是某些先加载？
        });*/

        /*国家边界线的source和layer*/
        map.addSource('states', {
            type: 'geojson',
            data: routes
        });

        map.addLayer({              /*用fill了，即使首尾点没重合，它也会自动给你加个尾点让它组成一个封闭形状*/
            "id": "state-fills",
            "type": "fill",       /* fill类型layer一般用来表示面 */
            "source": "states",
            "layout": {

            },
            "paint": {
                "fill-color": "#900", /* layer颜色 */
                "fill-opacity": 0      /* layer透明度 */
            }
        });

        map.addLayer({
            "id": "state-borders",
            "type": "line",      /* line类型layer表示线 */
            "source": "states",
            "layout": {

            },
            "paint": {
                "line-dasharray":[5,10],    /*虚线[实线长度，隐藏长度]*/
                "line-color": "#627BC1", /* 线条颜色 */
                "line-width": 2          /* 线条宽度 */
            },
            "filter": ["==", "name", ""]  /* 过滤器，名字为空的数据才显示，也就是默认不使用该layer  */
        });



        map.addLayer({
            "id": "state-fills-hover",
            "type": "circle",
            "source": "states",
            "layout": {},
            "paint": {
                "circle-opacity":1,
                "circle-radius": 4,
                "circle-color": "#900"
            },
            "filter": ["==", "name", ""]  /* 过滤器，名字为空的数据才显示，也就是默认不使用该layer  */
        });

        /*当前点的source和layer*/
        map.addSource('point', {
            "type": "geojson",
            "data": point
        });

        map.addLayer({
            "id": "point",
            "type": "circle",
            "source": "point",
            "paint": {
                "circle-radius": 10,
                "circle-color": "#3887be"
            }
        }, 'state-fills-hover');            //让这个layer在state-fills-hover下面

    });

    //1、鼠标点击后，显示鼠标所在国家的边界、在table中显示经纬度数据
    map.on("click", function(e) {
        var btnNum = e.originalEvent.button;        /*只有左键点击才有效，右键无效*/
        if(btnNum!=0) {         /*只有左键点击才有效，右键无效*/
            return;
        }
        var features = map.queryRenderedFeatures(e.point, { layers: ["state-fills"] });/*queryRenderedFeatures  ([geometry], [parameters]):返回满足查询条件并且能够可视化的Geojson特性对象数组，查询条件可以是layers或者filter，如果是layers，则在这些layer之内的特性能够返回  */
        if (features.length) {
            countryName=features[0].properties.name;
            map.setFilter("state-borders", ["==", "name", features[0].properties.name]); /* 通过设置filter更新要显示的数据，即出现鼠标悬停之后的变色效果 */
            map.setFilter("state-fills-hover", ["==", "name", features[0].properties.name]); /* 通过设置filter更新要显示的数据，即出现鼠标悬停之后的变色效果 */

            //features[0].geometry.coordinates这里的数据是能够可视化的Geojson特性对象数组，并不是routes里的原始数据，所以不用这里的数据，而是通过他的name来找对应的routes中的数据；
            // 这样就不会出现移点的时候其他点也跟着动，而且div中也不会少数据了
            for(var i=0;i<routes.features.length;i++){          /*获取当前选中的国家边界数据countryData*/
                if(routes.features[i].properties.name==countryName){
                    countryData=routes.features[i];
                }
            }
            //features[0].geometry.type=='Polygon'也是一样，当把地图无限放大以后，它就一直是polygon了，看来也是可视化的判断type
            if(countryData.geometry.type=='Polygon') {
                /*if(features[0].geometry.type=='Polygon'){*/
                /*countryData=turf.polygon(features[0].geometry.coordinates);*/
                /*修改/显示界面左上方div数据（国家边界点数据）*/
                var countryRoute = '';
                for (var i = 0; i < countryData.geometry.coordinates[0].length; i++) {
                    countryRoute += "<tr><td>" + (i + 1) + "</td><td><input type='number' step='0.001' name='lat' value='" + countryData.geometry.coordinates[0][i][1] + "' onchange=\"changePoint(this,-1,"+i+")\" /></td><td><input type='number' step='0.001'  name='lng' value='" + countryData.geometry.coordinates[0][i][0] + "' onchange=\"changePoint(this,-1,"+i+")\"  /></td>";
                    if (i == 0) {       //第一行没加号按钮
                        countryRoute += "</tr>";
                    } else {          //后面的有加号按钮
                        countryRoute += "<td><button class='btn-control' onclick=\"plusPoint(-1," + i + ")\">+</button></td></tr>";
                    }
                }
                $(".routeTablebody").html(countryRoute);
            }else if(countryData.geometry.type=='MultiPolygon'){
                /*}else if(features[0].geometry.type=='MultiPolygon'){*/
                /*countryData = turf.multiPolygon(features[0].geometry.coordinates);*/
                var countryRoute='';
                for(var j=0;j<countryData.geometry.coordinates.length;j++){
                    for(var i=0;i<countryData.geometry.coordinates[j][0].length;i++){
                        countryRoute+="<tr><td>"+(j+1)+"-"+(i+1)+"</td><td><input type='number' step='0.001'  name='lat' value='"+countryData.geometry.coordinates[j][0][i][1]+"' onchange=\"changePoint(this,"+j+","+i+")\" /></td><td><input type='number' step='0.001'  name='lng' value='"+countryData.geometry.coordinates[j][0][i][0]+"' onchange=\"changePoint(this,"+j+","+i+")\" /></td>";
                        if(i==0){       //第一行没加号按钮
                            countryRoute+="</tr>";
                        }else{          //后面的有加号按钮
                            countryRoute+="<td><button class='btn-control' onclick=\"plusPoint("+j+","+i+")\" >+</button></td></tr>";
                        }

                    }
                }
                $(".routeTablebody").html(countryRoute);
            }else{
                countryData='';
            }
        } else {
            map.setFilter("state-borders", ["==", "name", ""]);
            map.setFilter("state-fills-hover", ["==", "name", ""]);
            $(".routeTablebody").html("");
        }

        //4、点击table中的某一行的任意一点，会在地图中显示该点(这个函数要放在countryRoute加载后的函数后面，如果放在外面，就是一开始就加载这个函数，但是一开始tr，所以后来这个函数都不起作用)
        $(".routeTablebody tr").click(function(){
            var t=$(this).find("td:first").text();
            if(t.indexOf("\-")==-1){
                point.features[0].geometry.coordinates=[countryData.geometry.coordinates[0][t-1][0],countryData.geometry.coordinates[0][t-1][1]];
                map.getSource('point').setData(point);


            }else if(t.indexOf("\-")!=-1){
                var a=t.split("\-");
                point.features[0].geometry.coordinates=[countryData.geometry.coordinates[a[0]-1][0][a[1]-1][0],countryData.geometry.coordinates[a[0]-1][0][a[1]-1][1]];
                map.getSource('point').setData(point);
            }
        });

        //不加这个的话，第一次click后，描到一个点，再移出来还是蓝色的，所以就这句。
        map.on('mousemove', onPointMove);
    });

    //2、拖动坐标点
    map.on('mouseenter', function(e) {
        //如果已经有下标了，就不走onPointMove（）这个方法来找下标了
        if(currenti1==-1){
            onPointMove(e);
        }
    });

    map.on("mouseleave",function(e){
        currentj1=-1;
        currenti1=-1;
        currenti2=-1;
    });

    function onPointMove(e){
        currentj1=-1;
        currenti1=-1;
        currenti2=-1;
        var from = turf.point([e.lngLat.lng, e.lngLat.lat]);/* e.lngLat获取事件的位置 */
        var distance1=20;
        var features = map.queryRenderedFeatures(e.point, { layers: ['state-fills-hover'] });
        if (features.length) {
            if(countryData.geometry.type=='Polygon') {
                for (var i = 0; i < countryData.geometry.coordinates[0].length; i++) {
                    var to = turf.point([countryData.geometry.coordinates[0][i][0], countryData.geometry.coordinates[0][i][1]]);
                    var distance = turf.distance(from, to, "miles");
                    if(distance<20&&distance<distance1){        //通过distance1来跟distance比较，找出离当前鼠标所在位置最近的点；类似于勇哥在港口后面弄个隐藏点，只是我用的解析几何思想，distance就相当于是隐藏的点的半径了
                        currenti1 = i;
                        map.setPaintProperty('state-fills-hover', 'circle-color', '#3bb2d0'); /* 设置id为point的layer的circle-color的属性值 */
                        canvas.style.cursor = 'pointer';
                        isCursorOverPoint = true;
                        map.dragPan.disable();   /* 去使能DragPanHandler，此时拖拽时地图不动 */
                        distance1=distance;
                    }else if(distance<20&&currenti1!=-1&&countryData.geometry.coordinates[0][i][0]==countryData.geometry.coordinates[0][currenti1][0]&&countryData.geometry.coordinates[0][i][1]==countryData.geometry.coordinates[0][currenti1][1]){       //主要用来存尾点下标的，不过后来做了相邻国家下标，把这个方法也给做出来了
                        currenti2=i;
                        map.setPaintProperty('state-fills-hover', 'circle-color', '#3bb2d0'); /* 设置id为point的layer的circle-color的属性值 */
                        canvas.style.cursor = 'pointer';
                        isCursorOverPoint = true;
                        map.dragPan.disable();   /* 去使能DragPanHandler，此时拖拽时地图不动 */
                    }else{
                        continue;
                    }
                }
            }else if(countryData.geometry.type=='MultiPolygon'){
                for(var j=0;j<countryData.geometry.coordinates.length;j++){
                    for(var i=0;i<countryData.geometry.coordinates[j][0].length;i++){
                        var to = turf.point([countryData.geometry.coordinates[j][0][i][0], countryData.geometry.coordinates[j][0][i][1]]);
                        var distance = turf.distance(from, to, "miles");
                        if(distance<20&&distance<distance1){
                            currenti1=i;
                            currentj1=j;
                            map.setPaintProperty('state-fills-hover', 'circle-color', '#3bb2d0'); /* 设置id为point的layer的circle-color的属性值 */
                            canvas.style.cursor = 'pointer';
                            isCursorOverPoint = true;
                            map.dragPan.disable();   /* 去使能DragPanHandler，此时拖拽时地图不动 */
                            distance1=distance;
                        }else if(distance<20&&currenti1!=-1&&countryData.geometry.coordinates[j][0][i][0]==countryData.geometry.coordinates[currentj1][0][currenti1][0]&&countryData.geometry.coordinates[j][0][i][1]==countryData.geometry.coordinates[currentj1][0][currenti1][1]){
                            currenti2=i;
                            map.setPaintProperty('state-fills-hover', 'circle-color', '#3bb2d0'); /* 设置id为point的layer的circle-color的属性值 */
                            canvas.style.cursor = 'pointer';
                            isCursorOverPoint = true;
                            map.dragPan.disable();   /* 去使能DragPanHandler，此时拖拽时地图不动 */
                        }else{
                            continue;
                        }
                    }
                }
            }
        } else {
            map.setPaintProperty('state-fills-hover', 'circle-color', '#900');
            canvas.style.cursor = 'default';            //箭头
            isCursorOverPoint = false;
            map.dragPan.enable();
            currentj1=-1;
            currenti1=-1;
            currenti2=-1;
        }
    }

    map.on('mousedown', function(e){
        if (!isCursorOverPoint) return;

        //按下去的时候，就不能再找下标了，否则会一直找和鼠标当前位置相近的点，到最后所有点都重合在一起了
        map.off('mousemove', onPointMove);
        isDragging = true;

        canvas.style.cursor = 'grab';  /* 张开的手背朝上的小手样式 */
        var coords = e.lngLat;  /* e.lngLat获取事件的位置 */
        if(countryData.geometry.type=='Polygon'){
            //6、相邻国家边界--鼠标按下，查询相邻国家边界点在routes的下标
            aroundCountriesTypes=[];
            aroundCountriespoints=[];
            for(var i=0;i<routes.features.length;i++){
                if(routes.features[i].geometry.type=="Polygon"){
                    for(var j=0;j<routes.features[i].geometry.coordinates[0].length;j++){
                        if(routes.features[i].geometry.coordinates[0][j][1].toFixed(10)==countryData.geometry.coordinates[0][currenti1][1].toFixed(10)&&routes.features[i].geometry.coordinates[0][j][0].toFixed(10)==countryData.geometry.coordinates[0][currenti1][0].toFixed(10)){       /*.toFixed(10)：四舍五入几位小数*/
                            aroundCountriesTypes.push(routes.features[i].geometry.type);
                            aroundCountriespoints.push([i,j]);
                        }
                    }
                }else if(routes.features[i].geometry.type=="MultiPolygon"){
                    for(var j=0;j<routes.features[i].geometry.coordinates.length;j++){
                        for(var k=0;k<routes.features[i].geometry.coordinates[j][0].length;k++){
                            if(routes.features[i].geometry.coordinates[j][0][k][1].toFixed(10)==countryData.geometry.coordinates[0][currenti1][1].toFixed(10)&&routes.features[i].geometry.coordinates[j][0][k][0].toFixed(10)==countryData.geometry.coordinates[0][currenti1][0].toFixed(10)){
                                aroundCountriesTypes.push(routes.features[i].geometry.type);
                                aroundCountriespoints.push([i,j,k]);
                            }
                        }
                    }
                }
            }

        }else if(countryData.geometry.type=='MultiPolygon'){
            //6、相邻国家边界--鼠标按下，查询相邻国家边界点在routes的下标
            aroundCountriesTypes=[];
            aroundCountriespoints=[];
            for(var i=0;i<routes.features.length;i++){
                if(routes.features[i].geometry.type=="Polygon"){
                    for(var j=0;j<routes.features[i].geometry.coordinates[0].length;j++){
                        if(routes.features[i].geometry.coordinates[0][j][1].toFixed(10)==countryData.geometry.coordinates[currentj1][0][currenti1][1].toFixed(10)&&
                            routes.features[i].geometry.coordinates[0][j][0].toFixed(10)==countryData.geometry.coordinates[currentj1][0][currenti1][0].toFixed(10)){
                            aroundCountriesTypes.push(routes.features[i].geometry.type);
                            aroundCountriespoints.push([i,j]);
                        }
                    }
                }else if(routes.features[i].geometry.type=="MultiPolygon"){
                    for(var j=0;j<routes.features[i].geometry.coordinates.length;j++){
                        for(var k=0;k<routes.features[i].geometry.coordinates[j][0].length;k++){
                            if(routes.features[i].geometry.coordinates[j][0][k][1].toFixed(10)==countryData.geometry.coordinates[currentj1][0][currenti1][1].toFixed(10)&&
                                routes.features[i].geometry.coordinates[j][0][k][0].toFixed(10)==countryData.geometry.coordinates[currentj1][0][currenti1][0].toFixed(10)){
                                aroundCountriesTypes.push(routes.features[i].geometry.type);
                                aroundCountriespoints.push([i,j,k]);
                            }
                        }
                    }
                }
            }
        }

        //6、相邻国家边界--鼠标移动，相邻国家边界点跟着动
        //把所有这个点的经纬度都变为当前鼠标的坐标，既改了当前国家的，也改了相邻国家的
        for(var i=0;i<aroundCountriesTypes.length;i++){
            if(aroundCountriesTypes[i]=='Polygon'){
                routes.features[aroundCountriespoints[i][0]].geometry.coordinates[0][aroundCountriespoints[i][1]][1]=coords.lat;
                routes.features[aroundCountriespoints[i][0]].geometry.coordinates[0][aroundCountriespoints[i][1]][0]=coords.lng;
            }else if(aroundCountriesTypes[i]=='MultiPolygon'){
                routes.features[aroundCountriespoints[i][0]].geometry.coordinates[aroundCountriespoints[i][1]][0][aroundCountriespoints[i][2]][1]=coords.lat;
                routes.features[aroundCountriespoints[i][0]].geometry.coordinates[aroundCountriespoints[i][1]][0][aroundCountriespoints[i][2]][0]=coords.lng;

            }
        }
        map.getSource('states').setData(routes);

        // Mouse events
        map.on('mousemove', onMove);   /* 鼠标移动事件 */
        map.on('mouseup', onUp);     /* 鼠标松开事件 */
    });

    function onMove(e) {
        if (!isDragging) return;    //只有鼠标按下的时候，才能拖拽，否则无法拖拽
        var coords = e.lngLat;  /* e.lngLat获取事件的位置 */

        /*左下方显示鼠标的经纬度*/
        coordinates.style.display = 'block';  /* 设置样式是“显示”，显示坐标数据 */
        coordinates.innerHTML = 'Longitude: ' + coords.lng + '<br />Latitude: ' + coords.lat;
        canvas.style.cursor = 'default';

        canvas.style.cursor = 'pointer';          /* 设置光标样式，手背向上，抓住东西的小手样式 */
        point.features[0].geometry.coordinates=[];      //国家边界点移动时，蓝色瞄准点消失
        map.getSource('point').setData(point);

        if(countryData.geometry.type=='Polygon'){
            if(currenti1!=-1){      /* 修改Geojson数据 */
                countryData.geometry.coordinates[0][currenti1][1]=coords.lat;
                countryData.geometry.coordinates[0][currenti1][0]=coords.lng;
                if(currenti2!=-1){
                    countryData.geometry.coordinates[0][currenti2][1]=coords.lat;
                    countryData.geometry.coordinates[0][currenti2][0]=coords.lng;
                }

                var countryRoute='';
                for (var i = 0; i < countryData.geometry.coordinates[0].length; i++) {
                    countryRoute += "<tr><td>" + (i + 1) + "</td><td><input  type='number' step='0.001' name='lat' value='" + countryData.geometry.coordinates[0][i][1] + "' onchange=\"changePoint(this,-1,"+i+")\" /></td><td><input  type='number' step='0.001' name='lng' value='" + countryData.geometry.coordinates[0][i][0] + "' onchange=\"changePoint(this,-1,"+i+")\"  /></td>";
                    if (i == 0) {       //第一行没加号按钮
                        countryRoute += "</tr>";
                    } else {          //后面的有加号按钮
                        countryRoute += "<td><button class='btn-control' onclick=\"plusPoint(-1," + i + ")\">+</button></td></tr>";
                    }
                }
                $(".routeTablebody").html(countryRoute);
            }
        }else if(countryData.geometry.type=='MultiPolygon'){
            if(currenti1!=-1){      /* 修改Geojson数据 */
                countryData.geometry.coordinates[currentj1][0][currenti1][1]=coords.lat;
                countryData.geometry.coordinates[currentj1][0][currenti1][0]=coords.lng;
                if(currenti2!=-1){
                    countryData.geometry.coordinates[currentj1][0][currenti2][1]=coords.lat;
                    countryData.geometry.coordinates[currentj1][0][currenti2][0]=coords.lng;
                }

                var countryRoute='';
                for(var j=0;j<countryData.geometry.coordinates.length;j++){
                    for(var i=0;i<countryData.geometry.coordinates[j][0].length;i++){
                        countryRoute+="<tr><td>"+(j+1)+"-"+(i+1)+"</td><td><input  type='number' step='0.001' name='lat' value='"+countryData.geometry.coordinates[j][0][i][1]+"' onchange=\"changePoint(this,"+j+","+i+")\" /></td><td><input  type='number' step='0.001' name='lng' value='"+countryData.geometry.coordinates[j][0][i][0]+"' onchange=\"changePoint(this,"+j+","+i+")\" /></td>";
                        if(i==0){       //第一行没加号按钮
                            countryRoute+="</tr>";
                        }else{          //后面的有加号按钮
                            countryRoute+="<td><button class='btn-control' onclick=\"plusPoint("+j+","+i+")\" >+</button></td></tr>";
                        }

                    }
                }
                $(".routeTablebody").html(countryRoute);
            }
        }

        //6、相邻国家边界--鼠标移动，相邻国家边界点跟着动
        //把所有这个点的经纬度都变为当前鼠标的坐标，既改了当前国家的，也改了相邻国家的
        for(var i=0;i<aroundCountriesTypes.length;i++){
            if(aroundCountriesTypes[i]=='Polygon'){
                routes.features[aroundCountriespoints[i][0]].geometry.coordinates[0][aroundCountriespoints[i][1]][1]=coords.lat;
                routes.features[aroundCountriespoints[i][0]].geometry.coordinates[0][aroundCountriespoints[i][1]][0]=coords.lng;
            }else if(aroundCountriesTypes[i]=='MultiPolygon'){
                routes.features[aroundCountriespoints[i][0]].geometry.coordinates[aroundCountriespoints[i][1]][0][aroundCountriespoints[i][2]][1]=coords.lat;
                routes.features[aroundCountriespoints[i][0]].geometry.coordinates[aroundCountriespoints[i][1]][0][aroundCountriespoints[i][2]][0]=coords.lng;

            }
        }

        map.getSource('states').setData(routes);  /* 重新设置data：getSource(id):获取对应id的source，setData(data):设置source的data，基于该source的layer随data的改变，位置发生变化 */

        coordinates.style.display = 'block';  /* 设置样式是“显示”，显示坐标数据 */
        coordinates.innerHTML = 'Longitude: ' + coords.lng + '<br />Latitude: ' + coords.lat;
    }

    function onUp(e) {
        if (!isDragging) return;
        var coords = e.lngLat;

        coordinates.style.display = 'none';  /* 设置样式是“显示”，显示坐标数据 */
        coordinates.innerHTML = 'Longitude: ' + coords.lng + '<br />Latitude: ' + coords.lat;
        canvas.style.cursor = 'default';
        isDragging = false;

        // Unbind mouse events
        map.off('mousemove', onMove);  /* 移除mousemove监听器 */
        map.on('mousemove', onPointMove);   /*鼠标松开后，又可以继续找下标了，同时初始化下标为-1*/
        currentj1=-1;
        currenti1=-1;
        currenti2=-1;

        //4、点击table中的某一行的任意一点，会在地图中显示该点(这个函数要放在countryRoute加载后的函数后面，如果放在外面，就是一开始就加载这个函数，但是一开始tr，所以后来这个函数都不起作用)
        $(".routeTablebody tr").click(function(){
            var t=$(this).find("td:first").text();
            if(t.indexOf("\-")==-1){
                point.features[0].geometry.coordinates=[countryData.geometry.coordinates[0][t-1][0],countryData.geometry.coordinates[0][t-1][1]];
                map.getSource('point').setData(point);


            }else if(t.indexOf("\-")!=-1){
                var a=t.split("\-");
                point.features[0].geometry.coordinates=[countryData.geometry.coordinates[a[0]-1][0][a[1]-1][0],countryData.geometry.coordinates[a[0]-1][0][a[1]-1][1]];
                map.getSource('point').setData(point);
            }
        });

        aroundCountriesTypes=[];
        aroundCountriespoints=[];
    }

    //3、点击"+"号后，在table中加个中间点
    var x=0.01;
    function plusPoint(intermediatej,intermediatei){
        if(x==0.01){
            x=0.02;
        }else{
            x=0.01;
        }
        if(countryData.geometry.type=='Polygon'&&intermediatej==-1){
            countryData.geometry.coordinates[0].push([0,0]);
            for(var i=(countryData.geometry.coordinates[0].length)-1;i>=0;i--){
                if(i>intermediatei){
                    countryData.geometry.coordinates[0][i][1]=countryData.geometry.coordinates[0][i-1][1];
                    countryData.geometry.coordinates[0][i][0]=countryData.geometry.coordinates[0][i-1][0];
                }else if(i==intermediatei){
                    //不能加中点，因为我设的是polygon，即多边形，多边形的定义是相邻三个点不在同一直线上。如果设为中点，那么就会自动过滤掉中点坐标，只有地图放大后点才会显示出来；像美国边界就有一条长的直线，地图变大以后才显示出来
                    // 所以才会出现移动后中点反而显示出来了，因为那时已经没有连续三个点在同一直线上了
                    countryData.geometry.coordinates[0][i][1]=((countryData.geometry.coordinates[0][i][1]+countryData.geometry.coordinates[0][i-1][1])/2)+x;
                    countryData.geometry.coordinates[0][i][0]=((countryData.geometry.coordinates[0][i][0]+countryData.geometry.coordinates[0][i-1][0])/2)-x;
                }
            }


            var countryRoute='';
            for (var i = 0; i < countryData.geometry.coordinates[0].length; i++) {
                countryRoute += "<tr><td>" + (i + 1) + "</td><td><input  type='number' step='0.001' name='lat' value='" + countryData.geometry.coordinates[0][i][1] + "' onchange=\"changePoint(this,-1,"+i+")\" /></td><td><input  type='number' step='0.001' name='lng' value='" + countryData.geometry.coordinates[0][i][0] + "' onchange=\"changePoint(this,-1,"+i+")\"  /></td>";
                if (i == 0) {       //第一行没加号按钮
                    countryRoute += "</tr>";
                } else {          //后面的有加号按钮
                    countryRoute += "<td><button class='btn-control' onclick=\"plusPoint(-1," + i + ")\">+</button></td></tr>";
                }
            }
            $(".routeTablebody").html(countryRoute);


            for(var i=0;i<routes.features.length;i++){
                if(routes.features[i].properties.name==countryName){
                    routes.features[i].geometry.coordinates =countryData.geometry.coordinates;
                }
            }

            //6、相邻国家边界--添加中间点，相邻国家边界点也增加中间点
            aroundCountriesTypes=[];
            aroundCountriespoints=[];
            for(var i=0;i<routes.features.length;i++){
                if(routes.features[i].geometry.type=="Polygon"){
                    //两点都对应，为了数组不越界，需要把首尾拿出来单独讨论
                    for(var j=0;j<routes.features[i].geometry.coordinates[0].length;j++){
                        if(j!=0){
                            if(routes.features[i].geometry.coordinates[0][j][1].toFixed(10)==countryData.geometry.coordinates[0][intermediatei-1][1].toFixed(10)
                                &&routes.features[i].geometry.coordinates[0][j][0].toFixed(10)==countryData.geometry.coordinates[0][intermediatei-1][0].toFixed(10)&&
                                (routes.features[i].geometry.coordinates[0][j-1][1].toFixed(10)==countryData.geometry.coordinates[0][intermediatei+1][1].toFixed(10)
                                &&routes.features[i].geometry.coordinates[0][j-1][0].toFixed(10)==countryData.geometry.coordinates[0][intermediatei+1][0].toFixed(10))){
                                aroundCountriesTypes.push(routes.features[i].geometry.type);
                                aroundCountriespoints.push([i,j]);
                            }
                        }
                        else if(j!=routes.features[i].geometry.coordinates[0].length-1){
                            if(routes.features[i].geometry.coordinates[0][j][1].toFixed(10)==countryData.geometry.coordinates[0][intermediatei-1][1].toFixed(10)
                                &&routes.features[i].geometry.coordinates[0][j][0].toFixed(10)==countryData.geometry.coordinates[0][intermediatei-1][0].toFixed(10)&&
                                (routes.features[i].geometry.coordinates[0][j+1][1].toFixed(10)==countryData.geometry.coordinates[0][intermediatei+1][1].toFixed(10)
                                &&routes.features[i].geometry.coordinates[0][j+1][0].toFixed(10)==countryData.geometry.coordinates[0][intermediatei+1][0].toFixed(10))){
                                aroundCountriesTypes.push(routes.features[i].geometry.type);
                                aroundCountriespoints.push([i,j+1]);
                            }
                        }
                    }
                }else if(routes.features[i].geometry.type=="MultiPolygon"){
                    for(var j=0;j<routes.features[i].geometry.coordinates.length;j++){
                        for(var k=0;k<routes.features[i].geometry.coordinates[j][0].length;k++){
                            if(k!=0){
                                if(routes.features[i].geometry.coordinates[j][0][k][1].toFixed(10)==countryData.geometry.coordinates[0][intermediatei-1][1].toFixed(10)
                                    &&routes.features[i].geometry.coordinates[j][0][k][0].toFixed(10)==countryData.geometry.coordinates[0][intermediatei-1][0].toFixed(10)&&
                                    (routes.features[i].geometry.coordinates[j][0][k-1][1].toFixed(10)==countryData.geometry.coordinates[0][intermediatei+1][1].toFixed(10)
                                    &&routes.features[i].geometry.coordinates[j][0][k-1][0].toFixed(10)==countryData.geometry.coordinates[0][intermediatei+1][0].toFixed(10))){
                                    aroundCountriesTypes.push(routes.features[i].geometry.type);
                                    aroundCountriespoints.push([i,j,k]);
                                }
                            }else if(k!=routes.features[i].geometry.coordinates[j][0]-1){
                                if(routes.features[i].geometry.coordinates[j][0][k][1].toFixed(10)==countryData.geometry.coordinates[0][intermediatei-1][1].toFixed(10)
                                    &&routes.features[i].geometry.coordinates[j][0][k][0].toFixed(10)==countryData.geometry.coordinates[0][intermediatei-1][0].toFixed(10)&&
                                    (routes.features[i].geometry.coordinates[j][0][k+1][1].toFixed(10)==countryData.geometry.coordinates[0][intermediatei+1][1].toFixed(10)
                                    &&routes.features[i].geometry.coordinates[j][0][k+1][0].toFixed(10)==countryData.geometry.coordinates[0][intermediatei+1][0].toFixed(10))){
                                    aroundCountriesTypes.push(routes.features[i].geometry.type);
                                    aroundCountriespoints.push([i,j,k+1]);
                                }
                            }
                        }
                    }
                }

            }
            for(var i=0;i<aroundCountriesTypes.length;i++){
                if(aroundCountriesTypes[i]=='Polygon'){
                    var interCo=routes.features[aroundCountriespoints[i][0]].geometry.coordinates[0];
                    interCo.push([0,0]);
                    for(var j=(interCo.length)-1;j>=0;j--){
                        if(j>aroundCountriespoints[i][1]){
                            interCo[j][1]=interCo[j-1][1];
                            interCo[j][0]=interCo[j-1][0];
                        }else if(j==aroundCountriespoints[i][1]){           //这里不是算中点了，因为相邻国家的两点之间的中点不一定和选定国家的两点中点重合，所以直接让它等于countryData的点
                            interCo[j][1]=countryData.geometry.coordinates[0][intermediatei][1];
                            interCo[j][0]=countryData.geometry.coordinates[0][intermediatei][0];
                        }
                    }
                }else if(aroundCountriesTypes[i]=='MultiPolygon'){
                    var interCo=routes.features[aroundCountriespoints[i][0]].geometry.coordinates[aroundCountriespoints[i][1]][0];
                    interCo.push([0,0]);
                    for(var j=(interCo.length)-1;j>=0;j--){
                        if(j>aroundCountriespoints[i][2]){
                            interCo[j][1]=interCo[j-1][1];
                            interCo[j][0]=interCo[j-1][0];
                        }else if(j==aroundCountriespoints[i][2]){
                            interCo[j][1]=countryData.geometry.coordinates[0][intermediatei][1];
                            interCo[j][0]=countryData.geometry.coordinates[0][intermediatei][0];
                        }
                    }
                }
            }


        }else if(countryData.geometry.type=='MultiPolygon'){
            countryData.geometry.coordinates[intermediatej][0].push([0,0]);
            for(var i=(countryData.geometry.coordinates[intermediatej][0].length)-1;i>=0;i--){
                if(i>intermediatei){
                    countryData.geometry.coordinates[intermediatej][0][i][1]=countryData.geometry.coordinates[intermediatej][0][i-1][1];
                    countryData.geometry.coordinates[intermediatej][0][i][0]=countryData.geometry.coordinates[intermediatej][0][i-1][0];
                }else if(i==intermediatei){
                    countryData.geometry.coordinates[intermediatej][0][i][1]=((countryData.geometry.coordinates[intermediatej][0][i][1]+countryData.geometry.coordinates[intermediatej][0][i-1][1])/2)+x;
                    countryData.geometry.coordinates[intermediatej][0][i][0]=((countryData.geometry.coordinates[intermediatej][0][i][0]+countryData.geometry.coordinates[intermediatej][0][i-1][0])/2)-x;
                }
            }

            var countryRoute='';
            for(var j=0;j<countryData.geometry.coordinates.length;j++){
                for(var i=0;i<countryData.geometry.coordinates[j][0].length;i++){
                    countryRoute+="<tr><td>"+(j+1)+"-"+(i+1)+"</td><td><input  type='number' step='0.001' name='lat' value='"+countryData.geometry.coordinates[j][0][i][1]+"' onchange=\"changePoint(this,"+j+","+i+")\" /></td><td><input  type='number' step='0.001' name='lng' value='"+countryData.geometry.coordinates[j][0][i][0]+"' onchange=\"changePoint(this,"+j+","+i+")\" /></td>";
                    if(i==0){       //第一行没加号按钮
                        countryRoute+="</tr>";
                    }else{          //后面的有加号按钮
                        countryRoute+="<td><button class='btn-control' onclick=\"plusPoint("+j+","+i+")\" >+</button></td></tr>";
                    }

                }
            }
            $(".routeTablebody").html(countryRoute);


            for(var i=0;i<routes.features.length;i++){
                if(routes.features[i].properties.name==countryName){
                    routes.features[i].geometry.coordinates =countryData.geometry.coordinates;
                }
            }

            //6、相邻国家边界--添加中间点，相邻国家边界点也增加中间点
            aroundCountriesTypes=[];                                //和上面的相比，就多了个countryData的下标!!!!可以整合
            aroundCountriespoints=[];
            for(var i=0;i<routes.features.length;i++){
                if(routes.features[i].geometry.type=="Polygon"){
                    //两点都对应，为了数组不越界，需要把首尾拿出来单独讨论
                    for(var j=0;j<routes.features[i].geometry.coordinates[0].length;j++){       //现在是3-4的if语句，可以并成2-2的if语句，代码少点
                        if(j!=0){
                            if(routes.features[i].geometry.coordinates[0][j][1].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei-1][1].toFixed(10)
                                &&routes.features[i].geometry.coordinates[0][j][0].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei-1][0].toFixed(10)&&
                                (routes.features[i].geometry.coordinates[0][j-1][1].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei+1][1].toFixed(10)
                                &&routes.features[i].geometry.coordinates[0][j-1][0].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei+1][0].toFixed(10))){
                                aroundCountriesTypes.push(routes.features[i].geometry.type);
                                aroundCountriespoints.push([i,j]);
                            }
                        }else if(j!=routes.features[i].geometry.coordinates[0].length-1){
                            if(routes.features[i].geometry.coordinates[0][j][1].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei-1][1].toFixed(10)
                                &&routes.features[i].geometry.coordinates[0][j][0].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei-1][0].toFixed(10)&&
                                (routes.features[i].geometry.coordinates[0][j+1][1].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei+1][1].toFixed(10)
                                &&routes.features[i].geometry.coordinates[0][j+1][0].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei+1][0].toFixed(10))){
                                aroundCountriesTypes.push(routes.features[i].geometry.type);
                                aroundCountriespoints.push([i,j+1]);
                            }
                        }
                    }
                }else if(routes.features[i].geometry.type=="MultiPolygon"){
                    for(var j=0;j<routes.features[i].geometry.coordinates.length;j++){
                        for(var k=0;k<routes.features[i].geometry.coordinates[j][0].length;k++){
                            if(k!=0){
                                if(routes.features[i].geometry.coordinates[j][0][k][1].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei-1][1].toFixed(10)
                                    &&routes.features[i].geometry.coordinates[j][0][k][0].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei-1][0].toFixed(10)&&
                                    (routes.features[i].geometry.coordinates[j][0][k-1][1].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei+1][1].toFixed(10)
                                    &&routes.features[i].geometry.coordinates[j][0][k-1][0].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei+1][0].toFixed(10))){
                                    aroundCountriesTypes.push(routes.features[i].geometry.type);
                                    aroundCountriespoints.push([i,j,k]);
                                }
                            }else if(k!=routes.features[i].geometry.coordinates[j][0].length-1){
                                if(routes.features[i].geometry.coordinates[j][0][k][1].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei-1][1].toFixed(10)
                                    &&routes.features[i].geometry.coordinates[j][0][k][0].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei-1][0].toFixed(10)&&
                                    (routes.features[i].geometry.coordinates[j][0][k+1][1].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei+1][1].toFixed(10)
                                    &&routes.features[i].geometry.coordinates[j][0][k+1][0].toFixed(10)==countryData.geometry.coordinates[intermediatej][0][intermediatei+1][0].toFixed(10))){
                                    aroundCountriesTypes.push(routes.features[i].geometry.type);
                                    aroundCountriespoints.push([i,j,k+1]);
                                }
                            }
                        }
                    }
                }
            }
            for(var i=0;i<aroundCountriesTypes.length;i++){
                if(aroundCountriesTypes[i]=='Polygon'){
                    var interCo=routes.features[aroundCountriespoints[i][0]].geometry.coordinates[0];
                    interCo.push([0,0]);
                    for(var j=(interCo.length)-1;j>=0;j--){
                        if(j>aroundCountriespoints[i][1]){
                            interCo[j][1]=interCo[j-1][1];
                            interCo[j][0]=interCo[j-1][0];
                        }else if(j==aroundCountriespoints[i][1]){           //这里不是算中点了，因为相邻国家的两点之间的中点不一定和选定国家的两点中点重合，所以直接让它等于countryData的点
                            interCo[j][1]=countryData.geometry.coordinates[intermediatej][0][intermediatei][1];
                            interCo[j][0]=countryData.geometry.coordinates[intermediatej][0][intermediatei][0];
                        }
                    }
                }else if(aroundCountriesTypes[i]=='MultiPolygon'){
                    var interCo=routes.features[aroundCountriespoints[i][0]].geometry.coordinates[aroundCountriespoints[i][1]][0];
                    interCo.push([0,0]);
                    for(var j=(interCo.length)-1;j>=0;j--){
                        if(j>aroundCountriespoints[i][2]){
                            interCo[j][1]=interCo[j-1][1];
                            interCo[j][0]=interCo[j-1][0];
                        }else if(j==aroundCountriespoints[i][2]){
                            interCo[j][1]=countryData.geometry.coordinates[intermediatej][0][intermediatei][1];
                            interCo[j][0]=countryData.geometry.coordinates[intermediatej][0][intermediatei][0];
                        }
                    }
                }
            }

        }

        map.getSource('states').setData(routes);  /* 重新设置data：getSource(id):获取对应id的source，setData(data):设置source的data，基于该source的layer随data的改变，位置发生变化 */

        //4、点击table中的某一行的任意一点，会在地图中显示该点(这个函数要放在countryRoute加载后的函数后面，如果放在外面，就是一开始就加载这个函数，但是一开始tr，所以后来这个函数都不起作用)
        $(".routeTablebody tr").click(function(){
            var t=$(this).find("td:first").text();
            if(t.indexOf("\-")==-1){
                point.features[0].geometry.coordinates=[countryData.geometry.coordinates[0][t-1][0],countryData.geometry.coordinates[0][t-1][1]];
                map.getSource('point').setData(point);
            }else if(t.indexOf("\-")!=-1){
                var a=t.split("\-");
                point.features[0].geometry.coordinates=[countryData.geometry.coordinates[a[0]-1][0][a[1]-1][0],countryData.geometry.coordinates[a[0]-1][0][a[1]-1][1]];
                map.getSource('point').setData(point);
            }
        });
    }

    //4、点击table中的某一行的任意一点，会在地图中显示该点
    /*$("tr").unbind('click').click(function(){
     var t=$(this).find("td:first").val();
     alert(t);
     if(t.indexOf("\-")==-1){
     alert(1);
     }else if(t.indexOf("\-")!=-1){
     alert(2);
     }
     });*/

    //5、保存geojson数据到一个文件中-->http://blog.csdn.net/baidu_34036884/article/details/68070550
    //-->http://www.cnblogs.com/siyunianhua/p/6994299.html?utm_source=itdadao&utm_medium=referral
    $("#saveto").click(function(){
        saveAs(new Blob([JSON.stringify(routes)],{type: "text/plain;charset=" + 'ANSI'}),"naturalMap.json");
        alert("保存成功");
    });

    //7、在div的input框中改变值，地图坐标同时改变
    function changePoint(arg,changej,changei){      //onchange()方法 调用当前对象arg，j、i是下标
        /*$(".routeTablebody tr:eq("+changei+") input[name='lat']").val();      //当前选中的lat
        $(".routeTablebody tr:eq("+changei+") input[name='lng']").val();      //当前选中的lng*/
        currentj1=-1;
        currenti1=-1;
        currenti2=-1;
        if(changej==-1&&countryData.geometry.type=='Polygon'){
            currenti1=changei;
            aroundCountriesTypes=[];
            aroundCountriespoints=[];
            for(var i=0;i<routes.features.length;i++){
                if(routes.features[i].geometry.type=="Polygon"){
                    for(var j=0;j<routes.features[i].geometry.coordinates[0].length;j++){
                        if(routes.features[i].geometry.coordinates[0][j][1].toFixed(10)==countryData.geometry.coordinates[0][currenti1][1].toFixed(10)&&routes.features[i].geometry.coordinates[0][j][0].toFixed(10)==countryData.geometry.coordinates[0][currenti1][0].toFixed(10)){       /*.toFixed(10)：四舍五入几位小数*/
                            aroundCountriesTypes.push(routes.features[i].geometry.type);
                            aroundCountriespoints.push([i,j]);
                        }
                    }
                }else if(routes.features[i].geometry.type=="MultiPolygon"){
                    for(var j=0;j<routes.features[i].geometry.coordinates.length;j++){
                        for(var k=0;k<routes.features[i].geometry.coordinates[j][0].length;k++){
                            if(routes.features[i].geometry.coordinates[j][0][k][1].toFixed(10)==countryData.geometry.coordinates[0][currenti1][1].toFixed(10)&&routes.features[i].geometry.coordinates[j][0][k][0].toFixed(10)==countryData.geometry.coordinates[0][currenti1][0].toFixed(10)){
                                aroundCountriesTypes.push(routes.features[i].geometry.type);
                                aroundCountriespoints.push([i,j,k]);
                            }
                        }
                    }
                }
            }
            for(var i=0;i<aroundCountriesTypes.length;i++){
                if(aroundCountriesTypes[i]=='Polygon'){
                    //要用Number转型，因为从input得到的值是String类型的
                    routes.features[aroundCountriespoints[i][0]].geometry.coordinates[0][aroundCountriespoints[i][1]][1]=Number($(".routeTablebody tr:eq("+changei+") input[name='lat']").val());
                    routes.features[aroundCountriespoints[i][0]].geometry.coordinates[0][aroundCountriespoints[i][1]][0]=Number($(".routeTablebody tr:eq("+changei+") input[name='lng']").val());
                }else if(aroundCountriesTypes[i]=='MultiPolygon'){
                    routes.features[aroundCountriespoints[i][0]].geometry.coordinates[aroundCountriespoints[i][1]][0][aroundCountriespoints[i][2]][1]=Number($(".routeTablebody tr:eq("+changei+") input[name='lat']").val());
                    routes.features[aroundCountriespoints[i][0]].geometry.coordinates[aroundCountriespoints[i][1]][0][aroundCountriespoints[i][2]][0]=Number($(".routeTablebody tr:eq("+changei+") input[name='lng']").val());

                }
            }
            //蓝色点显示
            point.features[0].geometry.coordinates=[Number($(".routeTablebody tr:eq("+changei+") input[name='lng']").val()),Number($(".routeTablebody tr:eq("+changei+") input[name='lat']").val())];
            map.getSource('point').setData(point);

        }else if(changej!=-1&&countryData.geometry.type=='MultiPolygon'){
            /*$(arg).parent().parent().find("input[name='lat']").val();      //前挡选中的lat
            $(arg).parent().parent().find("input[name='lng']").val();       //当前选中的lng*/
            currenti1=changei;
            currentj1=changej;
            aroundCountriesTypes=[];
            aroundCountriespoints=[];
            for(var i=0;i<routes.features.length;i++){
                if(routes.features[i].geometry.type=="Polygon"){
                    for(var j=0;j<routes.features[i].geometry.coordinates[0].length;j++){
                        if(routes.features[i].geometry.coordinates[0][j][1].toFixed(10)==countryData.geometry.coordinates[currentj1][0][currenti1][1].toFixed(10)&&
                            routes.features[i].geometry.coordinates[0][j][0].toFixed(10)==countryData.geometry.coordinates[currentj1][0][currenti1][0].toFixed(10)){
                            aroundCountriesTypes.push(routes.features[i].geometry.type);
                            aroundCountriespoints.push([i,j]);
                        }
                    }
                }else if(routes.features[i].geometry.type=="MultiPolygon"){
                    for(var j=0;j<routes.features[i].geometry.coordinates.length;j++){
                        for(var k=0;k<routes.features[i].geometry.coordinates[j][0].length;k++){
                            if(routes.features[i].geometry.coordinates[j][0][k][1].toFixed(10)==countryData.geometry.coordinates[currentj1][0][currenti1][1].toFixed(10)&&
                                routes.features[i].geometry.coordinates[j][0][k][0].toFixed(10)==countryData.geometry.coordinates[currentj1][0][currenti1][0].toFixed(10)){
                                aroundCountriesTypes.push(routes.features[i].geometry.type);
                                aroundCountriespoints.push([i,j,k]);
                            }
                        }
                    }
                }
            }
            for(var i=0;i<aroundCountriesTypes.length;i++){
                if(aroundCountriesTypes[i]=='Polygon'){
                    routes.features[aroundCountriespoints[i][0]].geometry.coordinates[0][aroundCountriespoints[i][1]][1]=Number($(arg).parent().parent().find("input[name='lat']").val());
                    routes.features[aroundCountriespoints[i][0]].geometry.coordinates[0][aroundCountriespoints[i][1]][0]=Number($(arg).parent().parent().find("input[name='lng']").val());
                }else if(aroundCountriesTypes[i]=='MultiPolygon'){
                    routes.features[aroundCountriespoints[i][0]].geometry.coordinates[aroundCountriespoints[i][1]][0][aroundCountriespoints[i][2]][1]=Number($(arg).parent().parent().find("input[name='lat']").val());
                    routes.features[aroundCountriespoints[i][0]].geometry.coordinates[aroundCountriespoints[i][1]][0][aroundCountriespoints[i][2]][0]=Number($(arg).parent().parent().find("input[name='lng']").val());
                }
            }

            //蓝色点显示
            point.features[0].geometry.coordinates=[Number($(arg).parent().parent().find("input[name='lng']").val()),Number($(arg).parent().parent().find("input[name='lat']").val())];
            map.getSource('point').setData(point);
        }else{
            currentj1=-1;
            currenti1=-1;
            currenti2=-1;
        }

        for(var i=0;i<routes.features.length;i++){          /*获取当前选中的国家边界数据countryData*/
            if(routes.features[i].properties.name==countryName){
                countryData=routes.features[i];
            }
        }
        map.getSource('states').setData(routes);
    }

    //8、上传本地json文件
    $("#xFile").change(function(e){
        readfls(e)
    });

    //导入
    var ImportFile = null;
    var rABS=false;
    function file2Xce(f) {
        return new Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader.onload = function (e) {
                var data = e.target.result;
                var fr=JSON.parse(data);
                console.log(fr);
                routes={
                    "type": "FeatureCollection",
                    "features":[]
                };
                routes.type=fr.type;
                routes.features=fr.features;
                map.getSource('states').setData(routes);
            };
            if (rABS) {
                reader.readAsArrayBuffer(f);
            } else {
                reader.readAsBinaryString(f);
            }
        });
    };

    function readfls(e) {
        var fls=e.currentTarget.files;
        if (fls && fls.length > 0) {
            ImportFile = fls[0];
            var fileX = ImportFile.name.split(".").reverse()[0];
            var fileXyes = false;
            ["xlsx", "xlc", "xlm", "xls", "xlt", "xlw", "json"].forEach(function (value, index, array) {
                if (fileX === value) {
                    fileXyes = true;
                }
            });
            if (fileXyes) {
                file2Xce(ImportFile).then(function (t) {
                    console.log("执行完毕");
                });
            } else {
                alert("格式错误！请重新选择");
            }
        }
    }


</script>
</body>
</html>
